---
layout: single
title: Preguntas (y Respuestas) de C++ que te pueden hacer en una entrevista para Gameplay Programmer
header:
  teaser: /assets/images/thumbnails/entrevista-c++.jpg
categories:
  - Art√≠culos
tags:
  - C++
  - Trabajo
  - Entrevistas
published: true
---

En este post traigo una lista de preguntas frecuentes que he ido encontrando en las entrevistas que he ido haciendo durante mis primeros a√±os <!--more-->, normalmente para posiciones de Junior Gameplay Programmer / C++.

A√±adir que todas mis respuestas est√°n abiertas a debate y correcci√≥n! No dud√©is en completar o corregir mis respuestas si veis fallos o inconsistencias! ‚ö†Ô∏èü™≤üë®‚Äçüíª
La mejor informaci√≥n se obtiene de muchas fuentes! üìöüìöüó£Ô∏èüó£Ô∏è
{: .notice--info}

## üí¨ ¬øcu√°l es la diferencia entre 'struct' y 'class'?

> la diferencia m√°s destacable es que en class los miembros y la herencia son privados por defecto. Adem√°s de ofrecer mejores herramientas para la abstracci√≥n. Normalmente los structs se usan para datos puros y ya, mientras que class se usan cuando hay l√≥gica detr√°s.

## üí¨ ¬øc√≥mo podr√≠as saber si un int es impar ?

> con el operador m√≥dulo %

{% highlight c++ %}
if(n % 2 != 0) { /*n es impar*/ }
{% endhighlight %}

## üí¨ ¬øqu√© opinas de llamar a m√©todos virtuales en el constructor?

> es peligroso ya que dentro del constructor, el sistema de herencia no ha sobrescrito a√∫n las funciones virtuales. Por tanto se llamar√° √∫nicamente a la versi√≥n base del m√©todo.

## üí¨ ¬øque opinas de llamar a 'delete this'?

> lo peor de todo es que 'delete this' funciona. Recomendable no usarlo jam√°s obviamente, pero si se usa, recordad no acceder al objeto m√°s, a partir de esa l√≠nea ‡≤†_‡≤†

## üí¨ ¬øqu√© es el polimorfismo y para qu√© se usa?

> este concepto significa que puedes acceder a diferentes objetos mediante la misma interfaz, siempre que las clases de esos objetos, hereden o implementen esa interfaz com√∫n claro.

## üí¨ ¬øde d√≥nde viene el 'overhead' de las funciones virtuales?

> pueden introducir un ligero deterioro del rendimiento debido a que son resueltas en runtime mediante una tabla de definiciones (vtable).Lo cual a√±ade un nivel de indirecci√≥n que afecta al branch predictor de la cpu.

## üí¨ ¬ødiferencias entre malloc y new?

> new operador de c++, no requiere el n√∫m. de bytes a reservar, devuelve un puntero al tipo reservado, llama al constructor del objeto.

> malloc es una funci√≥n de c, requiere n√∫m. de bytes, retorna void*, no llama al constructor.

> (Entre otras)

## üí¨ ¬øcu√°l es el uso del dot product?

> En espacios 2D-3D el valor del dot product nos indica las direcciones relativas de ambos vectores mediante un valor. Si el valor es 1, apuntan en la misma direcci√≥n, -1 si opuesto y 0 si son perpendiculares.

## üí¨ ¬øcu√°l es el uso del cross product?

> el cross product retorna un vector perpendicular a los dos vectores introducidos. Dependiendo del sistema de coordenadas y de la rotaci√≥n de los vectores, el vector perpendicular puede tener una direcci√≥n o la opuesta (+1, -1)

## üí¨ ¬øsi te dieran la tarea de mejorar el framerate, que ser√≠a lo PRIMERO que har√≠as?

> esta la lanzo al p√∫blico, me apareci√≥ en una entrevista y me gust√≥ mucho üòÇ

> Lo primero, buscar que partes son las que m√°s tiempo del frame se est√°n llevando con herramientas de profiling, para centrarme en ellas.
Tambi√©n asegurarme de batchear geometr√≠a, occlusions varios, si hay streaming de datos muy masivos y checkear el n√∫m. de AIs üê£ Simplemente porque son los bottleneck que m√°s he encontrado en mi carrera.

## üí¨ ¬øcu√°l es la diferencia entre ++i, i++ y i+=1?

> importante el orden de las operaciones:

> - ++i suma 1 a i y retorna el valor
- i++ retorna el valor y DESPU√âS suma 1 al valor
- i+=1 es equivalente a ++i

## üí¨ ¬øqu√© es el 'time complexity' de un algoritmo?

> Es un 'orden de magnitud' que nos indica cu√°l es el coste en tiempo de un algoritmo. (Ver: Big O Notation)

> El orden de magnitud suele venir dado por el tama√±o del input del algoritmo.

## üí¨ ¬øcu√°l es el time complexity de 'imprimir todos los nodos de un binary tree'? üå≤

> O(n). Ya que se recorre 1 sola vez todo el conjunto de n nodos.

> O(n) se le denomina 'Linear Time'.

## üí¨ ¬ødeber√≠a un game engine usar la STL de C++?

> esta es una pregunta hist√≥rica y no tengo respuesta, la STL tiene ventajas y desventajas claro. Aunque las desventajas en mi opini√≥n afloran cuando quieres alcanzar cotas de rendimiento AAA+. Hace una d√©cada la STL era mucho m√°s limitada y con muchos m√°s problemas entre plataformas e interoperabilidad con C, que la versi√≥n actual. Desde C++ 11 la cosa ha ido mejorando mucho hasta la versi√≥n actual que te ofrece un mont√≥n de opciones muy s√≥lidas.

> Es sabido que EA tiene (o ten√≠a) su EA STL, la cual era una reimplementaci√≥n in-house de la STL de C++. Unreal por ejemplo, implementa su propia librer√≠a de containers.

> Como ejemplo pr√°ctico tomar√© la clase std::vector, un array din√°mico que va reservando memoria autom√°ticamente, std::vector inicia con una memoria inicializada por defecto, cuando se llena, se reserva m√°s y se reubican los elementos. Esto tiene un coste pero ganamos la capacidad de tener un array din√°mico. Es esto una desventaja, depende del caso, si no quieres que esto ocurra en tu engine, por X raz√≥n, entonces te tocar√° usar otra estructura de datos o reimplementar la clase vector.

## üí¨ ¬øcu√°l es la diferencia entre un puntero y un array?

> puntero es un valor que almacena una direcci√≥n de memoria. Array es una colecci√≥n de valores secuenciales almacenados en memoria.

> un puntero puede apuntar a la posici√≥n inicial de un array, lo cual puede confundir.

## üí¨ ¬øqu√© es un 'design pattern' y por qu√© son √∫tiles?

> son soluciones que explotan ciertos beneficios estructurales del c√≥digo en pos de generar un c√≥digo mantenible. Adem√°s otras personas pueden reconocer estos patrones (de ah√≠ su nombre) mejorando la legibilidad y la posibilidad de que el c√≥digo sea mantenido y extendido por otras personas.

## üí¨ ¬øcu√°l es la diferencia entre & y &&?

> & es 'bitwise AND' y && es un 'logical AND'

> & puede ser usado tambi√©n como operador l√≥gico, pero la ventaja de && es que solo checkea la parte m√°s izquierda de la expresi√≥n booleana y si es false, no sigue, muy conveniente.

## üí¨ ¬øqu√© hace la keyword 'mutable'? menciona un caso de uso

> **mutable** se usa para indicar que un miembro de una clase puede cambiar su valor ignorando las etiquetas **const** del m√©todo en el que se modifica. Su uso puede indicar un mal dise√±o, pero puede ser usado correctamente por ejemplo para cachear valores. Imaginemos que tenemos un contenedor custom, que tiene una funci√≥n get(int index) const, esa funci√≥n puede modificar el miembro mCache, con el √∫ltimo valor accedido y si se vuelve a acceder, podemos devolver mCache en lugar de buscarlo otra vez.

## üí¨ ¬øqu√© es un 'quadtree'? menciona un caso de uso.

> estructura de datos que subdivide el espacio en regiones cuadradas 2D (si es 3D es un octree). Puede subdividirse un nivel N de veces, hasta alcanzar el tama√±o m√≠nimo permitido para los nodos hoja.

> Un caso de uso podr√≠a ser checkear las colisiones entre colliders de una escena. Por fuerza bruta comprobamos NxN colliders. Pero realmente no tiene sentido comprobar si dos colliders est√°n colisionando si est√°n muy lejos. Un quadtree nos permite agrupar objetos en peque√±as regiones de tal forma que podemos reducir la cantidad de parejas de colliders a comprobar. De tal forma que si en un nodo hoja del quadtree solo tenemos 1 collider, podemos asegurar que no va a colisionar con nada en este punto del tiempo. Podemos ignorar el nodo.

> Si tenemos 2 o m√°s colliders en un nodo entonces podemos proceder a comprobar colisiones entre pares.

> Aqu√≠ un ejemplo visual de como funciona el quadtree implementado en mi engine Druid :)

> Ah√≠ se ve como va actualizando nodos hoja en funci√≥n de si tienen o no objetos dentro.

:-------------------------:|:-------------------------:
![]({{ '/' | absolute_url }}/assets/images/gifs/engine/10.gif){: .align-center} | ![]({{ '/' | absolute_url }}/assets/images/gifs/engine/11.gif){: .align-center}
![]({{ '/' | absolute_url }}/assets/images/gifs/engine/12.gif){: .align-center} | ![]({{ '/' | absolute_url }}/assets/images/gifs/engine/13.gif){: .align-center}