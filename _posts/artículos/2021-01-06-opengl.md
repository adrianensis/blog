---
layout: single
title: ProgramaciÃ³n de GrÃ¡ficos en OpenGL - Â¿Por dÃ³nde empezar?
header:
  teaser: /assets/images/thumbnails/opengl.jpg
categories:
  - ArtÃ­culos
tags:
  - OpenGL
  - Render
  - GrÃ¡ficos
  - API
  - MatemÃ¡ticas
published: true
---

Este post viene a ser una lista de conceptos a tener en cuenta para poder introducirse a OpenGL.
{: .notice--info}

## ğŸ”¢ MatemÃ¡ticas

Lo primero es inevitable, como Thanos, las matemÃ¡ticas
(â€˜â—‰âŒ“â—‰â€™)

Necesitaremos:

- aritmÃ©tica de vectores/matrices
- trigonometrÃ­a bÃ¡sica (conocer las operaciones cos y sin mÃ­nimo)

En cualquier libro de "matemÃ¡ticas para videojuegos" hay un capÃ­tulo que habla sobre ello ğŸ”¢ğŸ§®

## ğŸ–Œï¸ OpenGL

Segundo debemos entender QUÃ‰ es OpenGL ğŸ‘‰ es una API que te permite acceder a las capacidades de la GPU, nos abstrae de la complejidad de diferentes drivers y fabricantes y nos permite obtener/enviar informaciÃ³n y comandos para dibujar en pantalla. Esto de forma MUY resumida.

Ejemplos de otras APIs de grÃ¡ficos son: Vulkan, DirectX, Metal.

Pero para dibujar en pantalla, necesitamos algÃºn tipo de lienzo sobre el que dibujar, Â¿no? ğŸ¸ Dicho de otra forma, necesitamos abrir una ventana donde la GPU pueda dibujar contenido ğŸ¨ Como cada Sistema Operativo tiene un sistema de ventanas diferente, podemos usar una librerÃ­a como [GLFW](https://www.glfw.org/){:target="_blank"} que nos permite crear una ventana (y un contexto para OpenGL) de forma sencilla y sin preocuparnos del SO subyacente.

Una particularidad de OpenGL es que realmente es un **estÃ¡ndar**. Depende del fabricante/driver implementar la especificaciÃ³n de la API, ademÃ¡s, las funciones de OpenGL necesitan ser cargadas en run-time.

"Â¿Â¿Â¿(â—__â—) y quÃ© me quieres decir con eso???"
{: .notice--danger}

El caso es que para abstraernos de estos matices necesitaremos una librerÃ­a como GLAD, la cual se encargarÃ¡ de buscar y cargar la API de OpenGL para nosotros. En esta web podemos descargar la versiÃ³n de [GLAD](https://glad.dav1d.de){:target="_blank"} que necesitemos.

Para que se entienda mejor, sin GLAD tendrÃ­amos que buscar manualmente la direcciÃ³n de memoria de los puntos de entrada que el fabricante ofrece para las funciones de OpenGL.

Y creedme, **no queremos eso à² _à² **.

### ğŸ­ Pipeline GrÃ¡fico

El [pipeline grÃ¡fico](https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview) no es mÃ¡s que la secuencia de fases por las que pasa la informaciÃ³n en la GPU, desde que inicia el Draw Call (no exactamente, pero para simplificar) hasta que se renderiza por pantalla.

![Pipeline Grafico](https://www.khronos.org/opengl/wiki_opengl/images/thumb/RenderingPipeline.png/270px-RenderingPipeline.png){: .align-center}

### ğŸ—„ï¸ Buffers

Cuando queremos dibujar un triÃ¡ngulo, enviamos un buffer con los datos de ese triÃ¡ngulo a la GPU.

Un [buffer](https://www.khronos.org/opengl/wiki/Buffer_Object) no es mÃ¡s que un array de bytes que contiene info como:

- las posiciones de los vÃ©rtices (x,y,z)
- las coordenadas de las texturas (u,v)
- normales
- colores

En OpenGL existen muchas formas para enviar informaciÃ³n a la GPU en las que intervienen diferentes funciones y estructuras, solo para que nos suene la notaciÃ³n:

- glCreateBuffer
- glBindBuffer
- glBufferData
- glBufferSubData
- glMapBuffer
...

### âœï¸ Draw Call

Una vez esta informaciÃ³n esta almacenada en la memoria de la GPU, podemos enviar un comando especÃ­fico, generalmente conocido como 'Draw Call', que indica a la GPU que puede empezar a renderizar la informaciÃ³n que tiene en su memoria.

### ğŸ“ˆ Bottlenecks

Un **bottleneck** o '*cuello de botella*' en programaciÃ³n grÃ¡fica suele venir dado por un exceso de Draw Calls dentro de un mismo frame. La comunicaciÃ³n CPU-GPU + transferencia de datos de una pieza de hardware a otra es muy costosa. Por eso muchas optimizaciones en programaciÃ³n grÃ¡fica suelen basarse en reducir la informaciÃ³n para enviar a la GPU y reducir el nÃºmero de Draw Calls (idealmente a 1 por frame).

### ğŸ“ƒ Shaders

Un [**shader**](https://www.khronos.org/opengl/wiki/Shader) es un programa escrito en un lenguaje que la GPU puede comprender (o que se compila a algo que la GPU puede comprender) y se encarga de definir una lÃ³gica para una de las fases del Pipeline GrÃ¡fico. En [Shader Toy](https://shadertoy.com) podÃ©is cacharrear con shadersâœ¨

## â–¶ï¸ ExplicaciÃ³n en YouTube

Dado que esta introducciÃ³n es algo vaga, os dejo una explicaciÃ³n mÃ¡s interactiva que hice para YouTube tiempo atrÃ¡s, espero que os sirva para asentar mejor todo esto âœŒï¸ğŸ’š

{% include video id="wHNpT0ash3M" provider="youtube" %}

## ğŸ“„ Recursos

Para finalizar, os dejo una lista de mis recursos favoritos para iniciarse en OpenGL â­

### ğŸŒ Webs
- [http://learnopengl.com](http://learnopengl.com)
- [http://ogldev.org](http://ogldev.org)
- [http://songho.ca/opengl](http://songho.ca/opengl)

### â–¶ï¸ YouTube
- [TheCherno](https://www.youtube.com/c/TheChernoProject)
- [ThinMatrix](https://www.youtube.com/c/ThinMatrix)
- [cmyuksel](https://www.youtube.com/c/cmyuksel)
- [ogldev](https://www.youtube.com/c/OGLDEV)
- [VictorGordan](https://www.youtube.com/c/VictorGordan)
- [thebennybox](https://www.youtube.com/user/thebennybox)

### ğŸ“š Libros
- Beginning OpenGL Game Programming
- More OpenGL Game Prog.
- OpenGL Insights
